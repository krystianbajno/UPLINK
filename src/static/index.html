<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UPLINK Web Panel</title>
    <script>
        let socket;
        let passphrase = '';

        function connect() {
            const wsUrl = `ws://${window.location.hostname}:${window.location.port || '80'}`;

            socket = new WebSocket(wsUrl);

            socket.onmessage = async function(event) {
                try {
                    const reader = new FileReader();
                    reader.onload = async function() {
                        const encryptedData = new Uint8Array(reader.result);
                        console.log('Encrypted Data:', encryptedData);

                        const decryptedData = await decryptData(encryptedData);
                        console.log('Decrypted Data:', decryptedData);

                        const decompressedData = await decompressData(decryptedData);
                        console.log('Decompressed Data:', decompressedData);

                        try {
                            const decodedText = new TextDecoder().decode(decompressedData);
                            console.log('Decoded Text:', decodedText);

                            const response = JSON.parse(decodedText);
                            handleResponse(response);
                        } catch (jsonError) {
                            console.error('Failed to parse JSON:', jsonError);
                            console.error('Received data:', decompressedData);
                        }
                    };
                    reader.readAsArrayBuffer(event.data);
                } catch (error) {
                    console.error('Error processing message:', error);
                }
            };

            socket.onopen = function() {
                document.getElementById('status').innerText = "Connected";
                document.getElementById('status').className = "connected";
                setInterval(() => {
                    fetchFiles()
                }, 1000)
            };

            socket.onclose = function() {
                document.getElementById('status').innerText = "Disconnected";
                document.getElementById('status').className = "disconnected";
            };
        }

        function handleResponse(response) {
            if (response.FileList) {
                displayFiles(response.FileList.files);
            } else if (response.Message) {
                document.getElementById('output').innerText = response.Message.content;
            } else if (response.UserList) {
                document.getElementById('output').innerText = response.UserList.users.join('\n');
            } else if (response.FileData) {
                downloadDecryptedFile(response.FileData.file_path, response.FileData.data);
            } else if (response.CommandOutput) {
                document.getElementById('output').innerText = response.CommandOutput.output;
            }
        }

        function displayFiles(files) {
            const fileContainer = document.getElementById('files');
            fileContainer.innerHTML = '';
            files.forEach(file => {
                const fileElement = document.createElement('a');
                fileElement.href = '#';
                fileElement.innerText = file;
                fileElement.onclick = function() {
                    downloadFile(file);
                };
                fileContainer.appendChild(fileElement);
            });
        }

        function fetchFiles() {
            sendCommand("ListFiles");
        }

        function sendCommand(commandType, commandPayload = null) {
            let command;
            if (commandPayload) {
                command = JSON.stringify({ [commandType]: commandPayload });
            } else {
                command = JSON.stringify(commandType);
            }

            compressData(new TextEncoder().encode(command)).then(compressedCommand => {
                encryptData(compressedCommand).then(encryptedCommand => {
                    socket.send(encryptedCommand);
                });
            });
        }

        function downloadFile(filename) {
            const command = {
                file_path: filename,
                file_local_path: filename
            };
            sendCommand("GetFile", command);
        }

        function uploadFile() {
            const fileInput = document.getElementById("fileInput");
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const binaryData = new Uint8Array(event.target.result);
                    compressData(binaryData).then(compressedData => {
                        encryptData(compressedData).then(encryptedData => {
                            const command = {
                                file_path: file.name,
                                file_up_path: file.name,
                                data: Array.from(encryptedData)
                            };
                            sendCommand("PutFile", command);
                        });
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function downloadDecryptedFile(filename, data) {
            const binaryData = new Uint8Array(data);
            const blob = new Blob([binaryData], { type: "application/octet-stream" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        async function deriveKey(passphrase) {
            const encoder = new TextEncoder();
            const passphraseKey = encoder.encode(passphrase);
            const hkdfKey = await crypto.subtle.importKey(
                "raw",
                passphraseKey,
                { name: "HKDF" },
                false,
                ["deriveKey"]
            );
            return crypto.subtle.deriveKey(
                {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: new Uint8Array(0),
                    info: new Uint8Array(0)
                },
                hkdfKey,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptData(data) {
            const key = await deriveKey(passphrase);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encryptedData = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            const combinedData = new Uint8Array(iv.length + encryptedData.byteLength);
            combinedData.set(iv, 0);
            combinedData.set(new Uint8Array(encryptedData), iv.length);
            return combinedData;
        }

        async function decryptData(data) {
            const iv = data.slice(0, 12);
            const encrypted = data.slice(12);
            const key = await deriveKey(passphrase);
            try {
                const decryptedData = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encrypted
                );
                return new Uint8Array(decryptedData);
            } catch (e) {
                console.error('Decryption failed:', e);
                throw e;
            }
        }

        function compressData(data) {
            return new Promise(async (resolve, reject) => {
                try {
                    const cs = new CompressionStream('gzip');
                    const writer = cs.writable.getWriter();
                    writer.write(data);
                    writer.close();

                    const compressedStream = cs.readable;
                    const compressedChunks = [];
                    const reader = compressedStream.getReader();
                    let result;

                    while (!(result = await reader.read()).done) {
                        compressedChunks.push(result.value);
                    }

                    const compressedArrayBuffer = new Blob(compressedChunks).arrayBuffer();
                    resolve(compressedArrayBuffer);
                } catch (error) {
                    reject(error);
                }
            });
        }
        function decompressData(data) {
            return new Promise(async (resolve, reject) => {
                try {
                    const ds = new DecompressionStream('gzip');
                    const writer = ds.writable.getWriter();
                    writer.write(data);
                    writer.close();

                    const decompressedStream = ds.readable;
                    const decompressedChunks = [];
                    const reader = decompressedStream.getReader();
                    let result;

                    while (!(result = await reader.read()).done) {
                        decompressedChunks.push(result.value);
                    }

                    const decompressedArrayBuffer = new Blob(decompressedChunks).arrayBuffer();
                    resolve(decompressedArrayBuffer);
                } catch (error) {
                    reject(error);
                }
            });
        }

        function updatePassphrase() {
            passphrase = document.getElementById('passphrase').value;
        }
    </script>
    <style>
        body {
            margin-left: 16px;
            margin-top: 16px;
            background-color: #2a2a2a;
            color: white;
            font-family: monospace;
        }
        input {
          padding: 16px;
          width: 300px;
          font-size: 16px;
          background-color: #1a1a1a;
          color: white;
        }
        button {
          padding: 20px;
          margin-left: 8px;
          min-width: 120px;
          background-color: #1a1a1a;
          border: 0;
          color: white;
          cursor: pointer;
          transition: 0.2s;
          font-size: 16px;
        }
        button:hover {
          filter:contrast(2);
        }
        div {
           margin: 16px 0 16px 0;
        }
        #files {
          display: flex;
          flex-direction: column;
          font-size: 16px;
        }
        a { color: lime !important; }
        .disconnected { color: red }
        .connected { color: lime }
    </style>
</head>
<body>
    <h1>UPLINK Web Panel</h1>
    <pre>
ooooo     ooo ooooooooo.   ooooo        ooooo ooooo      ooo oooo    oooo 
`888'     `8' `888   `Y88. `888'        `888' `888b.     `8' `888   .8P'  
 888       8   888   .d88'  888          888   8 `88b.    8   888  d8'    
 888       8   888ooo88P'   888          888   8   `88b.  8   88888[      
 888       8   888          888          888   8     `88b.8   888`88b.    
 `88.    .8'   888          888       o  888   8       `888   888  `88b.  
   `YbodP'    o888o        o888ooooood8 o888o o8o        `8  o888o  o888o                                                                       
    </pre>
    <h2>Status: <span id="status" class="disconnected">Disconnected</span></h2>
    <p>In order to connect, please enter the shared passphrase into the input below and press connect.
    <div id="auth">
        <input type="text" id="passphrase" placeholder="Enter passphrase" oninput="updatePassphrase()">
        <button onclick="connect()">Connect</button>
    </div>
    <div id="upload">
        <input type="file" id="fileInput">
        <button onclick="uploadFile()">Upload</button>
    </div>
    <div id="download">
        <h2>Files</h2>
        <div id="files"></div>
    </div>
    <div id="exec">
        <input type="text" id="commandInput" placeholder="Enter command">
        <button onclick="sendCommand('Execute', { command: document.getElementById('commandInput').value })">Send Command</button>
    </div>
    <div>
        <h2>Server message:</h2>
        <pre id="output"></pre>
    </div>
</body>
</html>
